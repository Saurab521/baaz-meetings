import os
import json
import time
import threading
from datetime import datetime, timedelta, timezone
from typing import List, Dict, Any, Optional

from flask import Flask, jsonify, send_from_directory
from flask_socketio import SocketIO
import redis
from dateutil import parser as dateparser

import eventlet as _eventlet_module  # safe to import even if not used
try:
    import eventlet
    from eventlet.semaphore import Semaphore as EventletSemaphore
    EVENTLET_AVAILABLE = True
except Exception:
    eventlet = None
    EventletSemaphore = None
    EVENTLET_AVAILABLE = False

# Google libs (safe import)
GOOGLE_LIBS_AVAILABLE = False
try:
    from google.oauth2 import service_account
    from googleapiclient.discovery import build
    GOOGLE_LIBS_AVAILABLE = True
except Exception:
    GOOGLE_LIBS_AVAILABLE = False

# ---------- ENV CONFIG ----------
CALENDARS_JSON = os.getenv("CALENDARS_JSON", "[]")
try:
    CALENDARS = json.loads(CALENDARS_JSON)
    if not isinstance(CALENDARS, list):
        CALENDARS = []
except Exception:
    CALENDARS = []

POLL_INTERVAL = int(os.getenv("POLL_INTERVAL", "30"))
SERVICE_ACCOUNT_FILE = os.getenv("GOOGLE_SA_FILE", "/secrets/google-sa.json")
REDIS_HOST = os.getenv("REDIS_HOST", "redis")
REDIS_PORT = int(os.getenv("REDIS_PORT", "6379"))

# Stability (avoid flicker)
STABILITY_THRESHOLD = int(os.getenv("STABILITY_THRESHOLD", "2"))

# ---------- FLASK ----------
app = Flask(__name__, static_folder="/frontend")
socketio = SocketIO(app, cors_allowed_origins="*", async_mode="eventlet")

# ---------- REDIS ----------
r = None
try:
    r = redis.Redis(host=REDIS_HOST, port=REDIS_PORT, db=0, decode_responses=True)
    r.ping()
    app.logger.info("Connected to Redis")
except Exception as e:
    app.logger.warning("Redis not available: %s", e)
    r = None

# ---------- GOOGLE CLIENT ----------
calendar_service = None
if GOOGLE_LIBS_AVAILABLE and os.path.exists(SERVICE_ACCOUNT_FILE):
    try:
        creds = service_account.Credentials.from_service_account_file(
            SERVICE_ACCOUNT_FILE,
            scopes=["https://www.googleapis.com/auth/calendar.readonly"],
        )
        calendar_service = build("calendar", "v3", credentials=creds, cache_discovery=False)
        app.logger.info("Google Calendar client initialized.")
    except Exception as e:
        app.logger.warning("Google client init failed: %s", e)
        calendar_service = None
else:
    app.logger.warning("Google libs / service account missing.")

# green/thread-safe lock for calendar fetching
calendar_lock = None
if EVENTLET_AVAILABLE and EventletSemaphore is not None:
    calendar_lock = EventletSemaphore(1)
else:
    # fallback to regular threading.Lock if eventlet not present
    import threading as _threading
    calendar_lock = _threading.Lock()

# ---------- TIME HELPERS ----------

def now_utc() -> datetime:
    return datetime.now(timezone.utc)


def parse_dt(dt_str: Optional[str]) -> Optional[datetime]:
    """Parse date/datetime from Google Calendar format."""
    if not dt_str:
        return None
    try:
        dt = dateparser.parse(dt_str)
        if dt is None:
            return None
        if dt.tzinfo is None:
            dt = dt.replace(tzinfo=timezone.utc)
        return dt.astimezone(timezone.utc)
    except Exception:
        return None


# ---------- CALENDAR HELPERS ----------

def calendar_id_for_room(room_id: str) -> Optional[str]:
    """Return Google calendarId for stored room id."""
    if "@" in room_id:
        return room_id
    for item in CALENDARS:
        try:
            if str(item.get("id")) == str(room_id):
                return item.get("calendarId")
            if str(item.get("name")) == str(room_id):
                return item.get("calendarId")
        except:
            pass
    return None


# ---------- EVENT NORMALIZATION ----------

def normalize_event(ev):
    """
    Convert Google event → clean dict:
    - title
    - start: ISO string
    - end: ISO string
    - organizer: string
    - start_ts / end_ts: epoch ms
    """

    if not ev or not isinstance(ev, dict):
        return None

    # Accept dateTime or date (full-day)
    start_field = ev.get("start", {})
    end_field = ev.get("end", {})

    start_str = start_field.get("dateTime") or start_field.get("date") or None
    end_str = end_field.get("dateTime") or end_field.get("date") or None

    # Convert to timestamps
    sdt = parse_dt(start_str) if start_str else None
    edt = parse_dt(end_str) if end_str else None
    start_ts = int(sdt.timestamp() * 1000) if sdt else None
    end_ts = int(edt.timestamp() * 1000) if edt else None

    # Organizer → always string
    organizer = ""
    org = ev.get("organizer")
    if isinstance(org, dict):
        organizer = org.get("email") or org.get("displayName") or ""
    elif isinstance(org, str):
        organizer = org

    return {
        "id": ev.get("id"),
        "title": ev.get("summary") or ev.get("title") or "Meeting",
        "start": start_str,
        "end": end_str,
        "start_ts": start_ts,
        "end_ts": end_ts,
        "organizer": organizer
    }


# ---------- SUMMARY BUILDER ----------

def build_summary(events, count=2):
    """Return next `count` meetings summary."""
    if not events:
        return [], 0

    summary = []
    for ev in events[:count]:
        summary.append({
            "id": ev["id"],
            "title": ev["title"],
            "start": ev["start"],
            "end": ev["end"]
        })

    return summary, len(events)


# ---------- STATE STABILITY (NO FLICKER) ----------

def get_prev_state(room_key):
    """Load previous state from Redis."""
    try:
        if not r: return None
        raw = r.get(f"room:{room_key}:state")
        if raw:
            return json.loads(raw)
    except:
        pass
    return None


def save_state(room_key, state):
    """Save current state to Redis."""
    if not r:
        return
    try:
        r.set(f"room:{room_key}:state", json.dumps(state))
    except:
        pass


def apply_stability(room_key, computed_state):
    """
    Prevent flicker:
    - Room status flips only after STABILITY_THRESHOLD polls.
    """

    prev = get_prev_state(room_key) or {}
    prev_status = bool(prev.get("occupied", False))
    prev_stable = int(prev.get("_stable", 0))

    instant_status = bool(computed_state["occupied"])

    # stability algorithm
    if instant_status == prev_status:
        stable_value = prev_stable + 1
        final_status = instant_status
    else:
        # Needs threshold to flip
        if prev_stable + 1 >= STABILITY_THRESHOLD:
            stable_value = STABILITY_THRESHOLD
            final_status = instant_status
        else:
            stable_value = prev_stable + 1
            final_status = prev_status  # hold old status until confirmed

    # Build final
    final_state = {
        "occupied": final_status,
        "is_ongoing": bool(computed_state["current"]),
        "current": computed_state["current"],
        "next": computed_state["next"],
        "all": computed_state["all"],
        "summary": computed_state["summary"],
        "next_count": computed_state["next_count"],
        "_stable": stable_value,
        "last_success": now_utc().isoformat(),
        "last_error": None
    }

    save_state(room_key, final_state)
    return final_state
# ---------- GOOGLE FETCH HELPERS ----------

def fetch_events_for_range(calendar_id: str, start_iso: str, end_iso: str):
    """Fetch events from Google Calendar between two timestamps."""
    if calendar_service is None:
        return []

    try:
        # serialize access to the calendar client / underlying socket
        # calendar_lock supports both eventlet.Semaphore and threading.Lock semantics
        acquired = False
        try:
            calendar_lock.acquire()
            acquired = True

            result = calendar_service.events().list(
                calendarId=calendar_id,
                timeMin=start_iso,
                timeMax=end_iso,
                singleEvents=True,
                orderBy="startTime",
                maxResults=200,
            ).execute()
            return result.get("items", []) or []
        finally:
            if acquired:
                try:
                    calendar_lock.release()
                except Exception:
                    # sometimes eventlet Semaphore.release may behave slightly differently
                    pass

    except Exception as e:
        app.logger.warning("Calendar fetch error %s: %s", calendar_id, e)
        return []



def fetch_full_day_events(calendar_id: str):
    """
    Fetch **entire day** events (midnight to midnight),
    WORKS EVEN IF MEETING STARTS PAST 6 HOURS.
    """

    now = now_utc()

    start_day = datetime(now.year, now.month, now.day, 0, 0, 0, tzinfo=timezone.utc)
    end_day = start_day + timedelta(days=1)

    start_iso = start_day.isoformat().replace("+00:00", "Z")
    end_iso = end_day.isoformat().replace("+00:00", "Z")

    return fetch_events_for_range(calendar_id, start_iso, end_iso)


# ---------- COMPUTE NORMALIZED STATE ----------

def compute_normalized_state(raw_events):
    """
    Convert raw events → normalized events → compute:
      - current event
      - next event
      - full list
      - summary (first 2)
      - no flicker logic (that happens later)
    """

    # normalize
    normalized = []
    for ev in raw_events:
        ne = normalize_event(ev)
        if ne:
            normalized.append(ne)

    # sort by start time
    normalized.sort(key=lambda x: (x.get("start_ts") or 9999999999999))

    now_ms = int(now_utc().timestamp() * 1000)

    current = None
    next_ev = None

    for ev in normalized:
        st = ev.get("start_ts")
        en = ev.get("end_ts")

        if st and en:
            if st <= now_ms < en:
                current = ev
            elif st > now_ms and next_ev is None:
                next_ev = ev

    summary, next_count = build_summary(normalized, count=2)

    return {
        "occupied": bool(current),
        "current": current,
        "next": next_ev,
        "all": normalized,
        "summary": summary,
        "next_count": next_count
    }


# ---------- IMPROVED POLLER (NO FLICKER) ----------

def poller_loop():
    app.logger.info("Starting poller (interval=%s, stability=%s)", POLL_INTERVAL, STABILITY_THRESHOLD)

    while True:
        try:
            for room in CALENDARS:
                try:
                    rid = room.get("id") or room.get("name")
                    cal = room.get("calendarId")

                    if not cal:
                        continue

                    # fetch full day
                    raw_events = fetch_full_day_events(cal)

                    # compute normalized
                    computed_state = compute_normalized_state(raw_events)

                    # apply stability algorithm
                    final_state = apply_stability(rid, computed_state)

                    # emit via socket
                    try:
                        socketio.emit("room_state", {
                            "room_id": rid,
                            "state": final_state
                        }, namespace="/rooms")
                    except Exception:
                        pass

                    app.logger.debug("Polled %s → occupied=%s current=%s next=%s",
                                     rid, final_state["occupied"],
                                     bool(final_state["current"]),
                                     bool(final_state["next"]))

                except Exception as e:
                    app.logger.error("Poller room error: %s", e)

        except Exception as e:
            app.logger.error("Poller fatal error: %s", e)

        time.sleep(POLL_INTERVAL)
# ---------- API: ROOMS LIST ----------

@app.route("/api/rooms")
def api_rooms():
    """Return list of rooms with id, name, floor, calendarId."""
    return jsonify(CALENDARS)


# ---------- API: GET ROOM STATE (cached via Redis) ----------

@app.route("/api/rooms/<room_id>/state")
def api_room_state(room_id):
    """
    Return latest stable state:
      - occupied
      - current meeting
      - next meeting
      - summary
      - all meetings (optional)
    """

    key = f"room:{room_id}:state"

    try:
        if r:
            raw = r.get(key)
            if raw:
                return jsonify(json.loads(raw))
    except:
        pass

    # fallback
    return jsonify({
        "occupied": False,
        "current": None,
        "next": None,
        "summary": [],
        "next_count": 0,
        "_stable": 0,
        "last_error": "no redis state"
    })


# ---------- API: FULL DAY MEETINGS ----------

@app.route("/api/rooms/<room_id>/meetings-today")
def api_room_meetings_today(room_id):
    """Return full-day events for a room."""
    calendar_id = calendar_id_for_room(room_id)
    if not calendar_id:
        return jsonify([])

    try:
        raw_events = fetch_full_day_events(calendar_id)
        normalized = [normalize_event(ev) for ev in raw_events if normalize_event(ev)]
        normalized.sort(key=lambda ev: ev.get("start_ts") or 0)
        return jsonify(normalized)
    except Exception as e:
        return jsonify({"error": str(e)})


# ---------- API: BATCH - ROOMS + STATE ----------

@app.route("/api/rooms/list-with-state")
def api_list_with_state():
    """
    Return:
    [
       {
         "id": "turf-001",
         "name": "...",
         "floor": "...",
         "calendarId": "...",
         "state": { full room state }
       },
       ...
    ]
    """

    output = []

    for room in CALENDARS:
        rid = room.get("id") or room.get("name")

        # get redis state
        state = {}
        key = f"room:{rid}:state"

        try:
            if r:
                raw = r.get(key)
                if raw:
                    state = json.loads(raw)
        except:
            pass

        output.append({
            "id": room.get("id"),
            "name": room.get("name"),
            "floor": room.get("floor"),
            "calendarId": room.get("calendarId"),
            "state": state
        })

    return jsonify(output)


# ---------- STATIC FRONTEND ----------

@app.route("/", defaults={"path": ""})
@app.route("/<path:path>")
def serve_frontend(path):
    static_root = app.static_folder or "/frontend"
    fullpath = os.path.join(static_root, path)

    if path and os.path.exists(fullpath):
        return send_from_directory(static_root, path)

    index = os.path.join(static_root, "index.html")
    if os.path.exists(index):
        return send_from_directory(static_root, "index.html")

    return jsonify({"status": "ok", "message": "frontend missing"})
# ---------- HEALTH / DEBUG ----------

@app.route("/_health")
def health():
    """
    Simple health check:
      - returns ok + redis status + google client status
    """
    info = {
        "status": "ok",
        "redis": bool(r is not None),
        "google_client": bool(calendar_service is not None),
        "calendars_count": len(CALENDARS),
        "time": now_utc().isoformat()
    }
    return jsonify(info)


@app.route("/_version")
def version():
    return jsonify({"app": "meeting-display-backend", "version": "1.0.0", "time": now_utc().isoformat()})


# ---------- GRACEFUL SHUTDOWN HOOKS (best-effort) ----------

def stop_background_poller():
    # In this simplified setup we don't keep a stop flag; system will stop with process exit.
    # If you run in more managed env, consider using an Event to halt the poller cleanly.
    app.logger.info("Stopping poller (if running).")

# ---------- STARTUP ----------

def start_background_poller():
    """
    Start poller in a background greenlet/thread. Safe to call multiple times.
    """
    try:
        if EVENTLET_AVAILABLE and eventlet is not None:
            # spawn as greenlet under eventlet (non-blocking)
            eventlet.spawn_n(poller_loop)
            app.logger.info("Poller greenlet started (eventlet).")
        else:
            t = threading.Thread(target=poller_loop, daemon=True, name="poller-thread")
            t.start()
            app.logger.info("Poller thread started (threading).")
    except Exception as e:
        app.logger.exception("Failed to start poller: %s", e)


# If run as main, start poller and run SocketIO app (development)
if __name__ == "__main__":
    # start background poller
    start_background_poller()

    # Run Flask-SocketIO directly (development). In production you may use gunicorn + eventlet (as your Dockerfile does).
    socketio.run(app, host="0.0.0.0", port=8000, debug=False)

# When imported (e.g. by gunicorn), ensure poller starts once
else:
    # This block runs when gunicorn imports app (module-level import). Start poller once.
    start_background_poller()


# ---------- DEPLOYMENT NOTES (copy into README or Dockerfile comments) ----------
"""
Deployment notes:

1) Environment variables expected (set in docker-compose):
   - CALENDARS_JSON : JSON array of room objects, e.g.
     '[{"id":"turf-001","calendarId":"c_...@resource.calendar.google.com","name":"turf 001","floor":"Ground"}, {...}]'
   - GOOGLE_SA_FILE : Path to service account JSON inside container (e.g. /secrets/google-sa.json)
   - POLL_INTERVAL : poll interval in seconds (default 30)
   - REDIS_HOST : redis hostname (default 'redis')
   - REDIS_PORT : redis port (default '6379')
   - STABILITY_THRESHOLD : number of polls required to flip state (default 2)

2) Docker image:
   - Base: python:3.11-slim
   - Install: pip packages (flask, flask-socketio, google-api-python-client, google-auth, python-dateutil, redis)
   - Use gunicorn with eventlet worker for production:
       gunicorn -b 0.0.0.0:8000 app:app --workers=2 --worker-class eventlet

3) Google service account:
   - Create a service account with Calendar readonly scope
   - Share each calendar (resource) with the service account email
   - Place the JSON file under /opt/meeting-display/secrets/google-sa.json (mounted read-only into container)

4) Testing endpoints:
   - GET /api/rooms
   - GET /api/rooms/<room_id>/meetings-today
   - GET /api/rooms/<room_id>/state
   - GET /api/rooms/list-with-state
   - GET /api/rooms/meetings-today  (batch)
   - GET /_health

5) Frontend integration:
   - Prefer using batch endpoint `/api/rooms/list-with-state` to fetch all rooms + states in one call.
   - For per-room details, use `/api/rooms/<id>/meetings-today` which returns normalized events with `start`/`end` ISO and `start_ts`/`end_ts` epoch ms.

6) Logs & troubleshooting:
   - Check `docker-compose logs backend --tail 200` for poller and Google API errors.
   - If Google API errors appear, verify service account JSON file, calendar sharing and API quotas.

"""
